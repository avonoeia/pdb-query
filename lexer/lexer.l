%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Include the header generated by Bison. This header contains the enum definitions for tokens
#include "parser.tab.h" 

void yyerror(const char *s);
%}

/* --- REGULAR DEFINITIONS --- */

/* Basic building blocks */
DIGIT       [0-9]
LETTER      [a-zA-Z_]
WHITESPACE  [ \t\r\n]

/* Complex definitions built from blocks */
/* Matches integers (50) or floats (2.5) */
NUMBER      {DIGIT}+(\.{DIGIT}+)? 

/* Identifiers start with a letter/underscore, followed by alphanumerics */
ID          {LETTER}({LETTER}|{DIGIT}|\.)* 
STRING_LIT  \"[^\"]*\"

/* Single-line comments starting with # */
COMMENT     #.*

%%

"CONFIG"    { return CONFIG; }
"QUERY"     { return QUERY; }
"FIND"      { return FIND; }
"WHERE"     { return WHERE; }
"AND"       { return AND; }
"OR"        { return OR; }

"="         { return EQUALS; }
"<"         { return LESS; }
">"         { return GREATER; }
"("         { return LPAREN; }
")"         { return RPAREN; }

{NUMBER}    { 
    /* Store the value as a string for the parser to handle */
    yylval.str = strdup(yytext); 
    return NUMBER; 
}

{STRING_LIT} { 
    /* Strip the surrounding quotes before sending to parser */
    yylval.str = strndup(yytext + 1, yyleng - 2); 
    return STRING; 
}

{ID}        { 
    yylval.str = strdup(yytext); 
    return IDENTIFIER; 
}

{COMMENT}   { /* Ignore comments */ }

{WHITESPACE} { /* Ignore whitespace */ }

.           { 
    /* Catch-all for undefined characters */
    printf("Lexical Error: Unknown character '%s'\n", yytext); 
    exit(1);
}

%%

/* Valid C code required for Flex */
int yywrap() {
    return 1;
}

int main(int argc, char **argv) {
    int token;

    /* yylex() reads from 'stdin' by default. 
       Run this program and type your query, then press Ctrl+D (Linux/Mac) 
       or Ctrl+Z (Windows) to send EOF.
    */
    if (argc < 2) {
        printf("Error: no input file\n");
        return 1;
    } else if (argc > 2) {
        printf("Error: takes only one input file at a time but received %d\n", argc);
        return 1;
    } else {
        FILE* file = fopen(argv[1], "r");
        if (!file) {
            fprintf(stderr, "Error: could not open file\n");
            return 1;
        }
        yyin = file;
    }

    while ((token = yylex()) != 0) {
        printf("Found Token: %d | Text: '%s'\n", token, yytext);

        /* Optional: A switch statement to make the output readable */
        switch(token) {
            case CONFIG: printf("\t-> Type: Keyword (CONFIG)\n\n"); break;
            case QUERY:  printf("\t-> Type: Keyword (QUERY)\n\n"); break;
            case NUMBER: printf("\t-> Type: Value (Number)\n\n"); break;
            case IDENTIFIER: printf("\t-> Type: Identifier\n\n"); break;
            case STRING: printf("\t-> Type: String Literal\n\n"); break;
            /* Add other cases as needed */
            default: printf("\n");
        }
    }

    return 0;
}